package fastcgi

import (









































































































































































}	}		t.Errorf("Long value mismatch")	if decoded["LONG_PARAM"] != longValue {		}		t.Fatalf("DecodeParams failed: %v", err)	if err != nil {	decoded, err := DecodeParams(encoded)	encoded := EncodeParams(params)		}		"LONG_PARAM": longValue,	params := map[string]string{		}		longValue = "a" + longValue[1:]	for i := range longValue {	longValue := string(make([]byte, 200))	// Test with value > 127 bytes (requires 4-byte length encoding)func TestEncodeParamLongValue(t *testing.T) {}	}		}			t.Errorf("decoded[%q] = %q, want %q", name, decoded[name], value)		if decoded[name] != value {	for name, value := range params {		}		t.Fatalf("len(decoded) = %d, want %d", len(decoded), len(params))	if len(decoded) != len(params) {		}		t.Fatalf("DecodeParams failed: %v", err)	if err != nil {	decoded, err := DecodeParams(encoded)	encoded := EncodeParams(params)		}		"REQUEST_URI":     "/index.php?foo=bar",		"QUERY_STRING":    "foo=bar",		"REQUEST_METHOD":  "GET",		"SCRIPT_FILENAME": "/var/www/html/index.php",	params := map[string]string{func TestEncodeDecodeParams(t *testing.T) {}	}		t.Errorf("Content = %q, want %q", decoded.Content, content)	if !bytes.Equal(decoded.Content, content) {	}		t.Errorf("RequestID = %d, want 1", decoded.Header.RequestID)	if decoded.Header.RequestID != 1 {	}		t.Errorf("Type = %d, want %d", decoded.Header.Type, Stdout)	if decoded.Header.Type != Stdout {		}		t.Fatalf("DecodeRecord failed: %v", err)	if err != nil {	decoded, err := DecodeRecord(&buf)		}		t.Fatalf("Encode failed: %v", err)	if err := record.Encode(&buf); err != nil {	var buf bytes.Buffer		record := NewRecord(Stdout, 1, content)	content := []byte("Hello, FastCGI!")func TestRecordEncodeDecode(t *testing.T) {}	}		t.Errorf("ProtocolStatus = %d, want %d", decoded.ProtocolStatus, RequestComplete)	if decoded.ProtocolStatus != RequestComplete {	}		t.Errorf("AppStatus = %d, want 0", decoded.AppStatus)	if decoded.AppStatus != 0 {		}		t.Fatalf("DecodeEndRequestBody failed: %v", err)	if err != nil {	decoded, err := DecodeEndRequestBody(&buf)		}		t.Fatalf("Encode failed: %v", err)	if err := body.Encode(&buf); err != nil {	var buf bytes.Buffer		}		ProtocolStatus: RequestComplete,		AppStatus:      0,	body := &EndRequestBody{func TestEndRequestBodyEncodeDecode(t *testing.T) {}	}		t.Error("KeepConn() = false, want true")	if !decoded.KeepConn() {	}		t.Errorf("Flags = %d, want %d", decoded.Flags, FlagKeepConn)	if decoded.Flags != FlagKeepConn {	}		t.Errorf("Role = %d, want %d", decoded.Role, Responder)	if decoded.Role != Responder {		}		t.Fatalf("DecodeBeginRequestBody failed: %v", err)	if err != nil {	decoded, err := DecodeBeginRequestBody(&buf)		}		t.Fatalf("Encode failed: %v", err)	if err := body.Encode(&buf); err != nil {	var buf bytes.Buffer		}		Flags: FlagKeepConn,		Role:  Responder,	body := &BeginRequestBody{func TestBeginRequestBodyEncodeDecode(t *testing.T) {}	}		})			}				t.Errorf("ContentLength = %d, want %d", decoded.ContentLength, tt.contentLength)			if decoded.ContentLength != tt.contentLength {			}				t.Errorf("RequestID = %d, want %d", decoded.RequestID, tt.reqID)			if decoded.RequestID != tt.reqID {			}				t.Errorf("Type = %d, want %d", decoded.Type, tt.recType)			if decoded.Type != tt.recType {			}				t.Errorf("Version = %d, want %d", decoded.Version, Version1)			if decoded.Version != Version1 {						}				t.Fatalf("DecodeHeader failed: %v", err)			if err != nil {			decoded, err := DecodeHeader(&buf)						}				t.Fatalf("Encode failed: %v", err)			if err := header.Encode(&buf); err != nil {			var buf bytes.Buffer						header := NewHeader(tt.recType, tt.reqID, tt.contentLength)		t.Run(tt.name, func(t *testing.T) {	for _, tt := range tests {		}		{"Stdout", Stdout, 1, 256},		{"Stdin", Stdin, 1, 0},		{"Params", Params, 1, 100},		{"BeginRequest", BeginRequest, 1, 8},	}{		contentLength uint16		reqID         uint16		recType       uint8		name          string	tests := []struct {func TestHeaderEncodeDecode(t *testing.T) {)	"testing"	"bytes"