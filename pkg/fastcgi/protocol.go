package fastcgi







































































































































































































































































}	}, nil		Content: content,		Header:  header,	return &Record{		}		}			return nil, err		if _, err := io.ReadFull(r, padding); err != nil {		padding := make([]byte, header.PaddingLength)	if header.PaddingLength > 0 {	// Skip padding		}		}			return nil, err		if _, err := io.ReadFull(r, content); err != nil {	if header.ContentLength > 0 {	content := make([]byte, header.ContentLength)		}		return nil, err	if err != nil {	header, err := DecodeHeader(r)func DecodeRecord(r io.Reader) (*Record, error) {// DecodeRecord reads a complete FastCGI record from the reader}	return nil		}		}			return err		if _, err := w.Write(padding); err != nil {		padding := make([]byte, r.Header.PaddingLength)	if r.Header.PaddingLength > 0 {	// Write padding if needed		}		}			return err		if _, err := w.Write(r.Content); err != nil {	if r.Header.ContentLength > 0 {		}		return err	if err := r.Header.Encode(w); err != nil {func (r *Record) Encode(w io.Writer) error {// Encode writes the complete record to the writer}	}		Content: content,		Header:  NewHeader(recType, reqID, uint16(len(content))),	return &Record{func NewRecord(recType uint8, reqID uint16, content []byte) *Record {// NewRecord creates a new FastCGI record}	Content []byte	Header  *Headertype Record struct {// Record represents a complete FastCGI record}	return e, nil		copy(e.Reserved[:], buf[5:8])	}		ProtocolStatus: buf[4],		AppStatus:      binary.BigEndian.Uint32(buf[0:4]),	e := &EndRequestBody{		}		return nil, err	if _, err := io.ReadFull(r, buf); err != nil {	buf := make([]byte, 8)func DecodeEndRequestBody(r io.Reader) (*EndRequestBody, error) {// DecodeEndRequestBody reads an EndRequestBody from the reader}	return err	_, err := w.Write(buf)		copy(buf[5:8], e.Reserved[:])	buf[4] = e.ProtocolStatus	binary.BigEndian.PutUint32(buf[0:4], e.AppStatus)	buf := make([]byte, 8)func (e *EndRequestBody) Encode(w io.Writer) error {// Encode writes the EndRequestBody to the writer}	Reserved       [3]byte	ProtocolStatus uint8	AppStatus      uint32type EndRequestBody struct {// EndRequestBody represents the body of an EndRequest record}	return b, nil		copy(b.Reserved[:], buf[3:8])	}		Flags: buf[2],		Role:  binary.BigEndian.Uint16(buf[0:2]),	b := &BeginRequestBody{		}		return nil, err	if _, err := io.ReadFull(r, buf); err != nil {	buf := make([]byte, 8)func DecodeBeginRequestBody(r io.Reader) (*BeginRequestBody, error) {// DecodeBeginRequestBody reads a BeginRequestBody from the reader}	return err	_, err := w.Write(buf)		copy(buf[3:8], b.Reserved[:])	buf[2] = b.Flags	binary.BigEndian.PutUint16(buf[0:2], b.Role)	buf := make([]byte, 8)func (b *BeginRequestBody) Encode(w io.Writer) error {// Encode writes the BeginRequestBody to the writer}	return b.Flags&FlagKeepConn != 0func (b *BeginRequestBody) KeepConn() bool {// KeepConn returns true if the KeepConn flag is set}	Reserved [5]byte	Flags    uint8	Role     uint16type BeginRequestBody struct {// BeginRequestBody represents the body of a BeginRequest record}	return h, nil		}		return nil, ErrInvalidRecordType	if h.Type > MaxType {		}		return nil, ErrInvalidVersion	if h.Version != Version1 {		}		Reserved:      buf[7],		PaddingLength: buf[6],		ContentLength: binary.BigEndian.Uint16(buf[4:6]),		RequestID:     binary.BigEndian.Uint16(buf[2:4]),		Type:          buf[1],		Version:       buf[0],	h := &Header{		}		return nil, err	if _, err := io.ReadFull(r, buf); err != nil {	buf := make([]byte, HeaderLength)func DecodeHeader(r io.Reader) (*Header, error) {// DecodeHeader reads a FastCGI header from the reader}	return err	_, err := w.Write(buf)		buf[7] = h.Reserved	buf[6] = h.PaddingLength	binary.BigEndian.PutUint16(buf[4:6], h.ContentLength)	binary.BigEndian.PutUint16(buf[2:4], h.RequestID)	buf[1] = h.Type	buf[0] = h.Version	buf := make([]byte, HeaderLength)func (h *Header) Encode(w io.Writer) error {// Encode writes the header to the writer}	}		Reserved:      0,		PaddingLength: paddingLength,		ContentLength: contentLength,		RequestID:     reqID,		Type:          recType,		Version:       Version1,	return &Header{		paddingLength := uint8(-contentLength & 7)	// Calculate padding to align to 8-byte boundaryfunc NewHeader(recType uint8, reqID uint16, contentLength uint16) *Header {// NewHeader creates a new FastCGI header}	Reserved      uint8	PaddingLength uint8	ContentLength uint16	RequestID     uint16	Type          uint8	Version       uint8type Header struct {// Header represents a FastCGI record header)	ErrContentTooLarge   = errors.New("content length too large")	ErrRequestIDTooLarge = errors.New("request ID too large")	ErrInvalidRecordType = errors.New("invalid record type")	ErrInvalidVersion    = errors.New("invalid FastCGI version")var ()	FlagKeepConn = 1const (// Flags)	MaxBodyLength = 65535	// Max body length (2^16 - 1)	NullRequestID = 0	// Null request ID	HeaderLength = 8	// Header length	UnknownRole     = 3	Overloaded      = 2	CantMpxConn     = 1	RequestComplete = 0	// Protocol status codes	Filter     = 3	Authorizer = 2	Responder  = 1	// Request roles	MaxType          = UnknownType	UnknownType      = 11	GetValuesResult  = 10	GetValues        = 9	Data             = 8	Stderr           = 7	Stdout           = 6	Stdin            = 5	Params           = 4	EndRequest       = 3	AbortRequest     = 2	BeginRequest     = 1	// Record types	Version1 = 1	// Protocol versionconst (// FastCGI protocol constants)	"io"	"errors"	"encoding/binary"import (package fastcgi